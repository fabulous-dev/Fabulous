var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/architecture/xamarin.forms/virtualized-collections/",title:"Architecture - Virtualized collections",description:"Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",content:"Virtualized collection enables displaying a scrolling list of data while only instantiating the visible rows. When scrolling, the no longer visible rows are reused and updated with the new data.\nIn Xamarin.Forms, this is done via 2 controls: ListView and CollectionView. Also those controls support grouping data and displaying a group header/footer.\nMy main idea was to let the user pass in its data source and declare a template function (as well as 2 others for header/footer). Fabulous would just remap the data source (Seq.map templateFn items) and pass it to Xamarin.Forms, avoiding enumeration.\nUsages # let items = [ 1 .. 1000 ] ListView(items) (fun item -\u0026gt; TextCell($\u0026#34;{item}\u0026#34;)) CollectionView(items) (fun item -\u0026gt; Label($\u0026#34;{item}\u0026#34;)) // According to Xamarin.Forms documentation, when grouping, data source should be an IEnumerable of IEnumerable type Group(headerData: string, footerData: string, items: IEnumerable\u0026lt;int\u0026gt;) = inherit ObservableCollection\u0026lt;int\u0026gt;(items) member _.HeaderData = headerData member _.FooterData = footerData let groups = ObservableCollection\u0026lt;Group\u0026gt;( [ for i = 0 .. 100 do  Group($\u0026#34;Header {i}\u0026#34;, $\u0026#34;Footer {i}\u0026#34;, [1 .. 100]) ] ) // ListView has no Footer for groups GroupedListView(groups) (fun group -\u0026gt; TextCell(group.HeaderData)) (fun item -\u0026gt; TextCell($\u0026#34;{item}\u0026#34;)) GroupedCollectionView(items) (fun group -\u0026gt; Label(group.HeaderData)) (fun item -\u0026gt; Label($\u0026#34;{item}\u0026#34;) (fun group -\u0026gt; Label(group.FooterData)) How ListView and CollectionView work in Xamarin.Forms # Virtualization in ListView/CollectionView works by combining 2 properties:\n ItemsSource: a list of raw data DataTemplate: a template object used to describe what the row should look like  Given the MVVM nature of XF, row reuse is mostly driven by bindings. DataTemplate doesn\u0026rsquo;t know about the raw data it will receive and only setups binding.\n\u0026lt;ListView ItemsSource=\u0026#34;{Binding Items}\u0026#34;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextCell Text=\u0026#34;{Binding MyProperty}\u0026#34; /\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; Xamarin.Forms creates a row using the DataTemplate and sets its BindingContext with the raw item. This triggers refresh of the row UI. Same on row reuse, XF sets the new raw item into BindingContext and refreshes the bindings.\nThis model doesn\u0026rsquo;t work with Fabulous at all, due to the lack of Binding. Fortunately, we can work with DataTemplateSelector to access the current item before returning the appropriate DataTemplate. This allows Fabulous to support virtualization.\nHow it works in Fabulous # Semantically speaking, our Widget is very close to DataTemplate. They both describe what a specific piece of UI should look like. The main difference is that DataTemplate doesn\u0026rsquo;t know of the data it will work with in advance, whereas Widget has been built with that data.\nSo the main challenge was to make the 2 concepts compatible.\nSimple collections (aka not grouped) # Storing data and the template function # In Fabulous v1, we were creating all ViewElement items (Widget in v2) on each view update. This can be problematic in case you have a large number of items.\nActually thanks to how virtualization works, we only need to \u0026ldquo;process\u0026rdquo; a couple of items for the visible rows. No need to go create all widgets on each view update.\nTo support that, the following type has been created:\ntype WidgetItems\u0026lt;\u0026#39;T\u0026gt; = { // The raw list of data provided by the user OriginalItems: IEnumerable\u0026lt;\u0026#39;T\u0026gt; // Function to convert one item to a widget Template: \u0026#39;T -\u0026gt; Widget } This WidgetItems is created by the function ViewHelpers.buildItems and is stored directly in the ItemsSource scalar attribute.\nlet buildItems\u0026lt;\u0026#39;msg, \u0026#39;marker, \u0026#39;itemData, \u0026#39;itemMarker\u0026gt; key attrDef (items: seq\u0026lt;\u0026#39;itemData\u0026gt;) (itemTemplate: \u0026#39;itemData -\u0026gt; WidgetBuilder\u0026lt;\u0026#39;msg, \u0026#39;itemMarker\u0026gt;) = (...) static member inline ListView\u0026lt;\u0026#39;msg, \u0026#39;itemData, \u0026#39;itemMarker when \u0026#39;itemMarker :\u0026gt; ICell\u0026gt;(items: seq\u0026lt;\u0026#39;itemData\u0026gt;) = ViewHelpers.buildItems\u0026lt;\u0026#39;msg, IListView, \u0026#39;itemData, \u0026#39;itemMarker\u0026gt; ViewKeys.ListView ItemsViewOfCell.ItemsSource items Note the use of 'itemMarker to enforce the type of widget items\nKeeping the original items allows us to directly compare them on each update to determine if we need to update the UI.\n(fun (a, b) -\u0026gt; ScalarAttributeComparers.equalityCompare(a.OriginalItems, b.OriginalItems)) Currently, scalar attributes in Fabulous have 2 generic parameters: the 'inputType and 'modelType.\nThe 'inputType is what we expect the users to provide us. The 'modelType is an optimized representation of the same data (eg. 'inputType is int list, 'modelType will be int[]).\nBefore storing the attribute value, we convert 'inputType to 'modelType through the Convert function declared in the ScalarAttributeDefinition; 'inputType is never stored.\nBut the comparison function shown just above is only done between 2 'modelTypes, but ListView/CollectionView expect an IEnumerable and not a WidgetItems.\nSo to support this, we need another generic parameter 'valueType and the corresponding ConvertValue: 'modelType -\u0026gt; 'valueType function.\ntype ScalarAttributeDefinition\u0026lt;\u0026#39;inputType, \u0026#39;modelType, \u0026#39;valueType\u0026gt; = { (...) Compare: \u0026#39;modelType -\u0026gt; \u0026#39;modelType ConvertValue: \u0026#39;modelType -\u0026gt; \u0026#39;valueType } With this, we can still store and compare WidgetItems, but when we actually need to apply the value to the XF property, we call ConvertValue to transform it. Attributes that don\u0026rsquo;t need conversion can use the id function to make it transparent.\nFor WidgetItems, we build an IEnumerable on the fly using the original items and the template function before assigning it to the XF property ItemsSource.\n(fun modelValue -\u0026gt; seq { for x in modelValue.OriginalItems do modelValue.Template x }) Now Xamarin.Forms has a list of Widgets, and thanks to seq, it will only enumerate the items it needs to display.\nLoading Widgets into rows # Unlike DataTemplate in MVVM apps, instead of setting bindings to capture the raw data inside BindingContext, we now have a Widget.\nTo make it work, we need 2 things:\n A DataTemplateSelector that will know which DataTemplate to create based on the widget A DataTemplate that will listen to BindingContextChanged and run the Reconciler when a widget is attached to the row  // IsHeader is only for grouping type WidgetDataTemplateSelector internal (node: IViewNode, itemType: VirtualizedItemType) = inherit DataTemplateSelector() /// Reuse data template for already known widget target type  let cache = Dictionary\u0026lt;Type, WidgetDataTemplate\u0026gt;() override _.OnSelectTemplate(item, _) = let widget = BindableHelpers.getWidgetFromBindingContext itemType item let widgetDefinition = WidgetDefinitionStore.get widget.Key let targetType = widgetDefinition.GetTargetType(widget) match cache.TryGetValue(targetType) with | true, dataTemplate -\u0026gt; dataTemplate | false, _ -\u0026gt; let dataTemplate = WidgetDataTemplate(targetType, isHeader, node) cache.Add(targetType, dataTemplate) dataTemplate Note that like said earlier, DataTemplate are created before knowing which value they will host. This means we can only create an empty row for now. So to enable row reuse later, we extract the root target type of a widget and create an empty row with it.\neg.\nfun item -\u0026gt; ViewCell( Grid(...) ) will have a target type of ViewCell and we create an empty ViewCell.\nSide note: Given the potential high cost of instantiate a lot of View.lazy', its use is not allowed in virtualized collections.\nThis DataTemplateSelector instantiates a WidgetDataTemplate that will create the appropriate XF control and listen to BindingContextChanged.\n/// Create a DataTemplate for a specific root type (TextCell, ViewCell, etc.) /// that listen for BindingContext change to apply the Widget content to the cell type WidgetDataTemplate(``type``, itemType, parent: IViewNode) = inherit DataTemplate(fun () -\u0026gt; let bindableObject = Activator.CreateInstance ``type`` :?\u0026gt; BindableObject let viewNode = ViewNode(ValueSome parent, parent.TreeContext, WeakReference(bindableObject)) bindableObject.SetValue(ViewNode.ViewNodeProperty, viewNode) let onBindingContextChanged = BindableHelpers.createOnBindingContextChanged parent.TreeContext.CanReuseView itemType bindableObject bindableObject.BindingContextChanged.Add (fun _ -\u0026gt; onBindingContextChanged ()) bindableObject :\u0026gt; obj ) For fresh rows, Xamarin.Forms will execute that function and then set the BindingContext with the widget from our list. When XF reuses a row, it will set the new widget in the BindingContext as well. Each time, we call the Reconciler to update the row.\nFinal step is to pass this WidgetDataTemplateSelector in the XF property ItemTemplate. Since it will never change, we assign it when creating the controls.\n/// Force ListView to recycle rows because DataTemplateSelector disables it by default, only possible in ctor /// CollectionView recycles by default type FabulousListView() = inherit ListView(ListViewCachingStrategy.RecycleElement) let ListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) ) let CollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) ) A registerWithAdditionalSetup was needed because DataTemplateSelector requires access to the ViewNode of the ListView/CollectionView, and it was not possible to do it in the constructor of the controls.\nGrouped collections # Grouped ListView/CollectionView is slightly different. Instead of having a 1-dimensional enumerable of raw data, we have a 2-dimension one (eg. IEnumerable\u0026lt;IEnumerable\u0026lt;T\u0026gt;\u0026gt;)\nTo support this with everything we saw just before, GroupItem has been created.\ntype GroupItem(header: Widget, footer: Widget, source: IEnumerable\u0026lt;Widget\u0026gt;) = member _.Header = header member _.Footer = footer interface IEnumerable\u0026lt;Widget\u0026gt; with member this.GetEnumerator(): IEnumerator\u0026lt;Widget\u0026gt; = source.GetEnumerator() member this.GetEnumerator(): IEnumerator = source.GetEnumerator() Instead of applying a list of IEnumerable\u0026lt;Widget\u0026gt; to XF property ItemsSource, we apply a list of IEnumerable\u0026lt;GroupItem\u0026gt;.\nThe builder function takes 3 template functions instead of 1: the group header template, the item template and the group footer template. All of which are called on ConvertValue to create the list of \u0026lsquo;GroupItem\u0026rsquo;.\nSince the data source is different, we need a different DataTemplate for XF properties GroupHeaderTemplate and GroupFooterTemplate. Even with grouping enabled, ItemTemplate remains a simple Widget -\u0026gt; row.\nGroupedWidgetDataTemplateSelector will either use the Header or Footer widgets to create the corresponding rows.\nAnd when registering the ListView/CollectionView types, we enable the IsGrouped flag.\nlet GroupedListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.IsGroupingEnabled \u0026lt;- true ) let GroupedCollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.GroupFooterTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Footer) target.IsGrouped \u0026lt;- true ) "}).add({id:1,href:"/docs/prologue/introduction/",title:"Introduction",description:"Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",content:"Get started # There are two main ways to get started with Doks:\nTutorial # ðŸ‘‰  The Tutorial is intended for novice to intermediate users.   Step-by-step instructions on how to start a new Doks project. Tutorial â†’\nQuick Start # ðŸ‘‰  The Quick Start is intended for intermediate to advanced users.   One page summary of how to start a new Doks project.\nGo further # Recipes, Reference Guides, Extensions, and Showcase.\nRecipes # Get instructions on how to accomplish common tasks with Doks. Recipes â†’\nReference Guides # Learn how to customize Doks to fully make it your own. Reference Guides â†’\nExtensions # Get instructions on how to add even more to Doks. Extensions â†’\nShowcase # See what others have build with Doks. Showcase â†’\nContributing # Find out how to contribute to Doks. Contributing â†’\nHelp # Get help on Doks.\n"}).add({id:2,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}).add({id:3,href:"/docs/architecture/wip/",title:"",description:"Things to talk about #  Trees  UI tree VDOM tree  Widget Attributes (Scalar, Widget, WidgetColl)     Definitions + Builders Reconciler State ViewNode Runner + ViewAdapter  Xamarin.Forms\n Builders  Markers ViewBuilders Extensions    ",content:"Things to talk about #  Trees  UI tree VDOM tree  Widget Attributes (Scalar, Widget, WidgetColl)     Definitions + Builders Reconciler State ViewNode Runner + ViewAdapter  Xamarin.Forms\n Builders  Markers ViewBuilders Extensions    "}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()